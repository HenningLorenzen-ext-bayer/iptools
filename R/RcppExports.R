# This file was generated by Rcpp::compileAttributes
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' @title Returns the IP addresses associated with a hostname.
#' @description takes in a vector of hostnames and returns the IP addresses from
#' each hostname's DNS entries.
#' for each one.
#'
#' @param hostnames a vector of hostnames.
#'
#' @return a list the length of \code{hostnames}, containing the IP addresses from
#' each hostname's DNS entries. In the event that a hostname cannot be resolved,
#' the list element will consist of a length-1 character vector containing
#' "Not resolved".
#'
#' @examples
#' Takes in a hostname and returns all IP DNS entries for it. Not vectorized.
#'
#' \dontrun{
#' # One hostname
#' hostname_to_ip("dds.ec")
#' ## [1] "162.243.111.4"
#'
#' # Multiple hostnames
#' hostname_to_ip(c("dds.ec","ironholds.org"))
#' #[[1]]
#' #[1] "162.243.111.4"
#' #[[2]]
#' #[1] "104.131.2.226"
#' }
#' @export
hostname_to_ip <- function(hostnames) {
    .Call('iptools_hostname_to_ip', PACKAGE = 'iptools', hostnames)
}

#' @title Return the hostname associated with particular IP addresses
#' @description the opposite, in some ways, of \code{\link{hostname_to_ip}},
#' \code{ip_to_hostname} consumes a vector of IP addresses and provides a list of
#' the hostnames that those IPs resolve to.
#'
#' @param ip_addresses a vector of IP addresses.
#'
#' @return a list, each entry containing a vector of hostnames for the equivalent input
#' IP address (mostly, this will only be one hostname but not always). If the IP cannot be
#' resolved, the list element will be the string "Invalid IP address".
#'
#' @seealso \code{\link{hostname_to_ip}}, for the reverse operation.
#'
#' @examples
#' \dontrun{
#' ip_to_hostname("162.243.111.4")
#' [[1]]
#' [1] "dds.ec"
#' }
#'
#' @export
ip_to_hostname <- function(ip_addresses) {
    .Call('iptools_ip_to_hostname', PACKAGE = 'iptools', ip_addresses)
}

#' @title convert between numeric and dotted-decimal IPv4 forms.
#' @description \code{ip_to_numeric} takes IP addresses stored
#' in their human-readable representation ("192.168.0.1")
#' and converts it to a numeric representation (3232235521).
#' \code{numeric_to_ip} performs the same operation, but in reverse.
#' Due to limitations in R's support for colossally
#' big numbers, this currently only works for IPv4 IP addresses.
#'
#' @param ip_addresses a vector of IP addresses, in their numeric or dotted-decimal
#' form.
#'
#' @return For \code{ip_to_numeric}: a vector containing the numeric representation of \code{ip_addresses}.
#' If an IP is invalid (either because it's an Ipv6 address, or isn't an IP address
#' at all) the returned value for that IP will be -1.
#'
#' For \code{numeric_to_ip}: a vector containing the dotted-decimal representation of \code{ip_addresses},
#' as character strings. If a value cannot be resolved to an IPv4 address, it will appear as an empty
#' string.
#'
#' @examples
#' #Convert your local, internal IP to its numeric representation.
#' ip_to_numeric("192.168.0.1")
#' #[1] 3232235521
#'
#' #And back
#' numeric_to_ip(3232235521)
#' #[1] 192.168.0.1"
#' @rdname ip_numeric
#' @export
ip_to_numeric <- function(ip_addresses) {
    .Call('iptools_ip_to_numeric', PACKAGE = 'iptools', ip_addresses)
}

#' @rdname ip_numeric
#' @export
numeric_to_ip <- function(ip_addresses) {
    .Call('iptools_numeric_to_ip', PACKAGE = 'iptools', ip_addresses)
}

#'@title Identify whether an IP address is IPv4 or IPv6
#'@description Identify the form (IPv4 or IPv6) of a vector
#'of IP addresses. This can also be used to validate IPs.
#'
#'@param ip_addresses a vector of IPv4 or IPv6 IP addresses.
#'
#'@return a vector containing the class of each input IP address; either
#'"IPv4", "IPv6" or, for IP addresses that were not valid, "Invalid".
#'
#'@export
classify_ip <- function(ip_addresses) {
    .Call('iptools_classify_ip', PACKAGE = 'iptools', ip_addresses)
}

#' IPv4 CIDR to long integer range
#'
#' Converts IPv4 CIDR (e.g. "192.168.1.0/24") to vector containing the minimum and maximum range integer values
#'
#' @param cidr IPv4 CIDR (str) dotted-decimal-slash-integer
#' @return vector containing the minimum and maximum range integer values or \code{c(NA,NA)}
#' @examples
#' \dontrun{
#' long2ip(cidr_range("192.168.1.0/24"))
#' ## [1] "192.168.1.0"   "192.168.1.255"
#'
#' long2ip(cidr_range("8.0.0.0/8"))
#' ## [1] "8.0.0.0"       "8.255.255.255"
#'
#' cr <- cidr_range("172.18.0.0/28")
#' sapply(cr[1]:cr[2], long2ip)
#' ##  [1] "172.18.0.0"  "172.18.0.1"  "172.18.0.2"  "172.18.0.3"
#' ##  [5] "172.18.0.4"  "172.18.0.5"  "172.18.0.6"  "172.18.0.7"
#' ##  [9] "172.18.0.8"  "172.18.0.9"  "172.18.0.10" "172.18.0.11"
#' ## [13] "172.18.0.12" "172.18.0.13" "172.18.0.14" "172.18.0.15"
#' }
cidr_range <- function(cidr) {
    .Call('iptools_cidr_range', PACKAGE = 'iptools', cidr)
}

#' Test if IPv4 addresses are in a CIDR block
#'
#' Takes a vector of character IPv4 addresses and a character CIDR and
#' returs a logical vector indicating whether an IP address falls within
#' the specified CIDR
#'
#' @param ip character vector of IPv4 addresses
#' @param cidr atomic character vector (IPv4 CIDR spec)
#' @return logical vector of equivalent character (dotted-decimal) IP addresses
#' @examples
#' \dontrun{
#' table(ip_in_cidr(cidr_ips("192.168.0.0/23"), "192.168.1.0/24"))
#'
#' ## FALSE  TRUE
#' ##  256   256
#' }
ip_in_cidr <- function(ip, cidr) {
    .Call('iptools_ip_in_cidr', PACKAGE = 'iptools', ip, cidr)
}

