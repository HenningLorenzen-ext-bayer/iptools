# This file was generated by Rcpp::compileAttributes
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' @title Returns the IP addresses associated with a hostname.
#' @description takes in a vector of hostnames and returns the IP addresses from
#' each hostname's DNS entries.
#' for each one.
#'
#' @param hostnames a vector of hostnames.
#'
#' @return a list the length of \code{hostnames}, containing the IP addresses from
#' each hostname's DNS entries. In the event that a hostname cannot be resolved,
#' the list element will consist of a length-1 character vector containing
#' "Not resolved".
#'
#' @examples
#' Takes in a hostname and returns all IP DNS entries for it. Not vectorized.
#'
#' \dontrun{
#' # One hostname
#' hostname_to_ip("dds.ec")
#' ## [1] "162.243.111.4"
#'
#' # Multiple hostnames
#' hostname_to_ip(c("dds.ec","ironholds.org"))
#' #[[1]]
#' #[1] "162.243.111.4"
#' #[[2]]
#' #[1] "104.131.2.226"
#' }
#' @export
hostname_to_ip <- function(hostnames) {
    .Call('iptools_hostname_to_ip', PACKAGE = 'iptools', hostnames)
}

#' @title Return the hostname associated with particular IP addresses
#' @description the opposite, in some ways, of \code{\link{hostname_to_ip}},
#' \code{ip_to_hostname} consumes a vector of IP addresses and provides a list of
#' the hostnames that those IPs resolve to.
#'
#' @param ip_addresses a vector of IP addresses.
#'
#' @return a list, each entry containing a vector of hostnames for the equivalent input
#' IP address (mostly, this will only be one hostname but not always). If the IP cannot be
#' resolved, the list element will be the string "Invalid IP address".
#'
#' @seealso \code{\link{hostname_to_ip}}, for the reverse operation.
#'
#' @examples
#' \dontrun{
#' ip_to_hostname("162.243.111.4")
#' [[1]]
#' [1] "dds.ec"
#' }
#'
#' @export
ip_to_hostname <- function(ip_addresses) {
    .Call('iptools_ip_to_hostname', PACKAGE = 'iptools', ip_addresses)
}

#' Character (dotted-decimal) IPv4 Address Conversion to long integer
#'
#' Convert IP addresses in character (dotted-decimal) notation to long integers
#'
#' @param ip input character vector of IPv4 addresses (dotted-decimal)
#' @return vector of equivalent long integer IP addresses
#' @examples
#' \dontrun{
#' ip2long("24.0.5.11")ghb
#' ip2long(c("24.0.5.11", "211.3.77.96"))
#' }
ip2long <- function(ip) {
    .Call('iptools_ip2long', PACKAGE = 'iptools', ip)
}

#' Intger IPv4 Address Conversion to Character
#'
#' Converts IP addresses in long integer format to character (dotted-decimal) notation
#'
#' @param ip input numeric (long integer) vector
#' @return vector of equivalent character (dotted-decimal) IP addresses
#' @examples
#' \dontrun{
#' long2ip(402654475)
#' long2ip(c(402654475, 3540208992))
#' }
long2ip <- function(ip) {
    .Call('iptools_long2ip', PACKAGE = 'iptools', ip)
}

#' IPv4 CIDR to long integer range
#'
#' Converts IPv4 CIDR (e.g. "192.168.1.0/24") to vector containing the minimum and maximum range integer values
#'
#' @param cidr IPv4 CIDR (str) dotted-decimal-slash-integer
#' @return vector containing the minimum and maximum range integer values or \code{c(NA,NA)}
#' @examples
#' \dontrun{
#' long2ip(cidr_range("192.168.1.0/24"))
#' ## [1] "192.168.1.0"   "192.168.1.255"
#'
#' long2ip(cidr_range("8.0.0.0/8"))
#' ## [1] "8.0.0.0"       "8.255.255.255"
#'
#' cr <- cidr_range("172.18.0.0/28")
#' sapply(cr[1]:cr[2], long2ip)
#' ##  [1] "172.18.0.0"  "172.18.0.1"  "172.18.0.2"  "172.18.0.3"
#' ##  [5] "172.18.0.4"  "172.18.0.5"  "172.18.0.6"  "172.18.0.7"
#' ##  [9] "172.18.0.8"  "172.18.0.9"  "172.18.0.10" "172.18.0.11"
#' ## [13] "172.18.0.12" "172.18.0.13" "172.18.0.14" "172.18.0.15"
#' }
cidr_range <- function(cidr) {
    .Call('iptools_cidr_range', PACKAGE = 'iptools', cidr)
}

#' Test if IPv4 addresses are in a CIDR block
#'
#' Takes a vector of character IPv4 addresses and a character CIDR and
#' returs a logical vector indicating whether an IP address falls within
#' the specified CIDR
#'
#' @param ip character vector of IPv4 addresses
#' @param cidr atomic character vector (IPv4 CIDR spec)
#' @return logical vector of equivalent character (dotted-decimal) IP addresses
#' @examples
#' \dontrun{
#' table(ip_in_cidr(cidr_ips("192.168.0.0/23"), "192.168.1.0/24"))
#'
#' ## FALSE  TRUE
#' ##  256   256
#' }
ip_in_cidr <- function(ip, cidr) {
    .Call('iptools_ip_in_cidr', PACKAGE = 'iptools', ip, cidr)
}

