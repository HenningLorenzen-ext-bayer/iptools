# This file was generated by Rcpp::compileAttributes
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Returns all \code{A} records associated with a hostname
#'
#' Takes in a hostname and returns all IP DNS entries for it. Not vectorized.
#'
#' @param hostname character string of host to lookup
#' @return vector IP addresses
#' @examples
#' \dontrun{
#' # forward
#' gethostbyname("dds.ec")
#' ## [1] "162.243.111.4"
#'
#' # multiple return values
#' gethostbyname("google.com")
#' ##  [1] "2607:f8b0:4006:806::100e" "74.125.226.14"
#' ##  [3] "74.125.226.8"             "74.125.226.3"
#' ##  [5] "74.125.226.6"             "74.125.226.4"
#' ##  [7] "74.125.226.9"             "74.125.226.0"
#' ##  [9] "74.125.226.2"             "74.125.226.1"
#' ## [11] "74.125.226.5"             "74.125.226.7"
#' }
gethostbyname <- function(hostname) {
    .Call('iptools_gethostbyname', PACKAGE = 'iptools', hostname)
}

#' Returns all \code{PTR} records associated with an IPv4 address
#'
#' Takes in an IPv4 address and returns all IP reverse DNS entries for it. Not vectorized.
#'
#' @param ipv4 character string (dotted-decimal) IPv4 address
#' @return vector of hostnames (will usually be just a single host)
#' @examples
#' \dontrun{
#' # reverse
#' gethostbyaddr(gethostbyname("dds.ec"))
#' ## [1] "162.243.111.4"
#' }
gethostbyaddr <- function(ipv4) {
    .Call('iptools_gethostbyaddr', PACKAGE = 'iptools', ipv4)
}

#' Character (dotted-decimal) IPv4 Address Conversion to long integer
#'
#' Convert IP addresses in character (dotted-decimal) notation to long integers
#'
#' @param ip input character vector of IPv4 addresses (dotted-decimal)
#' @return vector of equivalent long integer IP addresses
#' @examples
#' \dontrun{
#' ip2long("24.0.5.11")ghb
#' ip2long(c("24.0.5.11", "211.3.77.96"))
#' }
ip2long <- function(ip) {
    .Call('iptools_ip2long', PACKAGE = 'iptools', ip)
}

#' Intger IPv4 Address Conversion to Character
#'
#' Converts IP addresses in long integer format to character (dotted-decimal) notation
#'
#' @param ip input numeric (long integer) vector
#' @return vector of equivalent character (dotted-decimal) IP addresses
#' @examples
#' \dontrun{
#' long2ip(402654475)
#' long2ip(c(402654475, 3540208992))
#' }
long2ip <- function(ip) {
    .Call('iptools_long2ip', PACKAGE = 'iptools', ip)
}

#' IPv4 CIDR to long integer range
#'
#' Converts IPv4 CIDR (e.g. "192.168.1.0/24") to vector containing the minimum and maximum range integer values
#'
#' @param cidr IPv4 CIDR (str) dotted-decimal-slash-integer
#' @return vector containing the minimum and maximum range integer values or \code{c(NA,NA)}
#' @examples
#' \dontrun{
#' long2ip(cidr_range("192.168.1.0/24"))
#' ## [1] "192.168.1.0"   "192.168.1.255"
#'
#' long2ip(cidr_range("8.0.0.0/8"))
#' ## [1] "8.0.0.0"       "8.255.255.255"
#'
#' cr <- cidr_range("172.18.0.0/28")
#' sapply(cr[1]:cr[2], long2ip)
#' ##  [1] "172.18.0.0"  "172.18.0.1"  "172.18.0.2"  "172.18.0.3"
#' ##  [5] "172.18.0.4"  "172.18.0.5"  "172.18.0.6"  "172.18.0.7"
#' ##  [9] "172.18.0.8"  "172.18.0.9"  "172.18.0.10" "172.18.0.11"
#' ## [13] "172.18.0.12" "172.18.0.13" "172.18.0.14" "172.18.0.15"
#' }
cidr_range <- function(cidr) {
    .Call('iptools_cidr_range', PACKAGE = 'iptools', cidr)
}

#' Test if IPv4 addresses are in a CIDR block
#'
#' Takes a vector of character IPv4 addresses and a character CIDR and
#' returs a logical vector indicating whether an IP address falls within
#' the specified CIDR
#'
#' @param ip character vector of IPv4 addresses
#' @param cidr atomic character vector (IPv4 CIDR spec)
#' @return logical vector of equivalent character (dotted-decimal) IP addresses
#' @examples
#' \dontrun{
#' table(ip_in_cidr(cidr_ips("192.168.0.0/23"), "192.168.1.0/24"))
#'
#' ## FALSE  TRUE
#' ##  256   256
#' }
ip_in_cidr <- function(ip, cidr) {
    .Call('iptools_ip_in_cidr', PACKAGE = 'iptools', ip, cidr)
}

#' Initializes the MaxMind library and opens the \code{GeoLiteCity.dat} & \code{GeoLiteASNum.dat} file
#'
#' This function must be called before performing a lookup with \code{geoip()} or \code{asnip()}.
#' Each full path spec prefix defaults to \code{/usr/local/share/GeoIP/}
#' and can be overriden by changing the value of the \code{citydata}  & \code{asndata} parameters.
#'
#' NOTE: You must manually retrieve the \code{GeoLiteCity.dat.gz} \code{GeoLiteASNum.dat.gz} files from MaxMind
#' via \url{http://geolite.maxmind.com/download/geoip/database/GeoLiteCity.dat.gz} &
#' \url{http://geolite.maxmind.com/download/geoip/database/GeoLiteASNum.dat.gz}  and
#' unzip each to the locations you will be specifying in the parameters.
#'
#' Any errors reading the files will result in a console message.
#'
#' @param citydata full path (including filename) to the \code{GeoLiteCity.dat} file
#' @param asndata full path (including filename) to the \code{GeoLiteASNum.dat} file
#' @examples
#' \dontrun{
#' maxmindinit()
#' }
maxmindinit <- function(citydata = "/usr/local/share/GeoIP/GeoLiteCity.dat", asndata = "/usr/local/share/GeoIP/GeoIPASNum.dat") {
    invisible(.Call('iptools_maxmindinit', PACKAGE = 'iptools', citydata, asndata))
}

#' Return a data frame of geolcation values for IPv4 address
#'
#' Uses the maxmind \code{GeoIPCity.dat} binary file to perform a geolocation for
#' a given IPv4 address and returns a data frame of geolocation records.
#' You should call \code{maxmindinit()} before calling \code{geoip()}, but \code{geoip}
#' will make a last-ditch effort to load the city database from the default location
#' in the event you forget.
#'
#' Values returned in the data frame:
#' \itemize{
#'   \item \code{ip}. original IP address (chr)
#'   \item \code{country.code}. ISO2 country code (chr)
#'   \item \code{country.code3}. ISO3 country code (chr)
#'   \item \code{region}. Abbreviated region name (chr)
#'   \item \code{region.name}. Full region name (chr)
#'   \item \code{city}. City name (chr)
#'   \item \code{postal.code}. Postal code (chr)
#'   \item \code{latitude}. Latitude (numeric)
#'   \item \code{lontigude}. Longitude (numeric)
#'   \item \code{time.zone}. Time zone (chr)
#'   \item \code{metro.code}. Metro code (int)
#'   \item \code{area.code}. Area code (int)
#' }
#'
#' @param ip character vector of IPv4 addresses to lookup
#' @param showMessages show/hide console messages (bool) default: do not show messages
#' @return data frame of geolocation information for the IP addresses
#' @note  vectorized
#' @examples
#' \dontrun{
#' maxmindinit()
#' geoip(c("24.24.24.24", "42.42.42.42", "8.8.8.8"))
#' ##            ip country.code country.code3       country.name region region.name      city
#' ## 1 24.24.24.24           US           USA      United States     NY    New York Deer Park
#' ## 2 42.42.42.42           KR           KOR Korea, Republic of     NA          NA        NA
#' ## 3     8.8.8.8           US           USA      United States     NA          NA        NA
#' ##   postal.code latitude longitude        time.zone metro.code area.code
#' ## 1       11729  40.7627  -73.3227 America/New_York        501       631
#' ## 2          NA  37.5700  126.9800       Asia/Seoul          0         0
#' ## 3          NA  38.0000  -97.0000               NA          0         0
#' }
geoip <- function(ip, showMessages = FALSE) {
    .Call('iptools_geoip', PACKAGE = 'iptools', ip, showMessages)
}

#' Return a data frame of IPv4 to ASN & org mappings
#'
#' Uses the maxmind \code{GeoIPASNum.dat} binary file to perform an AS number & org
#' identification for a given IPv4 address and returns a data frame of results.
#' You should call \code{maxmindinit()} before calling \code{asnip()}, but \code{asnip}
#' will make a last-ditch effort to load the ASNum database from the default location
#' in the event you forget.
#'
#' Values returned in the data frame:
#' \itemize{
#'   \item \code{ip}. original IP address (chr)
#'   \item \code{asn}. ASN (chr)
#'   \item \code{org}. Assigned org (chr)
#' }
#'
#' @param ip character vector of IPv4 addresses to lookup
#' @param includeAS (bool) whether to include or not include the "AS" prefix in the \code{asnum} column (default TRUE)
#' @param showMessages show/hide console messages (bool) default: do not show messages
#' @return data frame of AS # & org information for the IP addresses
#' @note vectorized
#' @examples
#' \dontrun{
#' maxmindinit()
#' set.seed(1000000); asnip(randomIPs(10))
#' ##                 ip     asn                         org
#' ## 1       70.5.34.39  AS3651                      Sprint
#' ## 2    79.32.183.102  AS3269       Telecom Italia S.p.a.
#' ## 3     70.166.53.78 AS36801   New Wave Industries, Inc.
#' ## 4  131.199.143.169  AS1341 Allen-Bradley Company, Inc.
#' ## 5    160.150.52.98  AS1515        Headquarters, USAISC
#' ## 6   242.119.216.60    <NA>                        <NA>
#' ## 7     53.55.24.145 AS31399   Daimler Autonomous System
#' ## 8   151.141.222.29 AS19956          BellSouth.net Inc.
#' ## 9  243.118.250.204    <NA>                        <NA>
#' ## 10   83.173.28.251 AS31441  Gagnaveita Reykjavikur ehf
#' }
asnip <- function(ip, includeAS = TRUE, showMessages = FALSE) {
    .Call('iptools_asnip', PACKAGE = 'iptools', ip, includeAS, showMessages)
}

#' Called when finished performing geolocation operations
#'
#' This frees the memory associated with the geolocation file.
#'
#' @examples
#' \dontrun{
#' geoCleanup()
#' }
geoCleanup <- function() {
    invisible(.Call('iptools_geoCleanup', PACKAGE = 'iptools'))
}

